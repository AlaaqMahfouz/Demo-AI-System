"use strict";
/*
* The MIT License (MIT)
*
* Copyright (c) 2003-2023 Aspose Pty Ltd
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents an barcode.
 */
class Barcode {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Barcode.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Barcode.attributeTypeMap = [
    {
        name: "codeTypeName",
        baseName: "codeTypeName",
        type: "string",
    },
    {
        name: "value",
        baseName: "value",
        type: "string",
    },
    {
        name: "downloadUrl",
        baseName: "downloadUrl",
        type: "string",
    }
];
exports.Barcode = Barcode;
/**
 * Represents page object with barcode.
 */
class BarcodePage {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return BarcodePage.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
BarcodePage.attributeTypeMap = [
    {
        name: "index",
        baseName: "index",
        type: "number",
    }
];
exports.BarcodePage = BarcodePage;
/**
 * Barcodes result.
 */
class BarcodesResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return BarcodesResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
BarcodesResult.attributeTypeMap = [
    {
        name: "barcodes",
        baseName: "barcodes",
        type: "Array<Barcode>",
    }
];
exports.BarcodesResult = BarcodesResult;
/**
 * Represents a container item like Zip archive entity, email attachment, PDF Portfolio item and so on.
 */
class ContainerItem {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ContainerItem.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ContainerItem.attributeTypeMap = [
    {
        name: "name",
        baseName: "name",
        type: "string",
    },
    {
        name: "filePath",
        baseName: "filePath",
        type: "string",
    },
    {
        name: "directory",
        baseName: "directory",
        type: "string",
    },
    {
        name: "metadata",
        baseName: "metadata",
        type: "{ [key: string]: string; }",
    }
];
exports.ContainerItem = ContainerItem;
/**
 * Container item info.
 */
class ContainerItemInfo {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ContainerItemInfo.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ContainerItemInfo.attributeTypeMap = [
    {
        name: "relativePath",
        baseName: "relativePath",
        type: "string",
    },
    {
        name: "password",
        baseName: "password",
        type: "string",
    }
];
exports.ContainerItemInfo = ContainerItemInfo;
/**
 * Container result.
 */
class ContainerResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ContainerResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ContainerResult.attributeTypeMap = [
    {
        name: "containerItems",
        baseName: "containerItems",
        type: "Array<ContainerItem>",
    }
];
exports.ContainerResult = ContainerResult;
/**
 * Class for rectangle coordinates.
 */
class Coordinates {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Coordinates.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Coordinates.attributeTypeMap = [
    {
        name: "top",
        baseName: "top",
        type: "number",
    },
    {
        name: "bottom",
        baseName: "bottom",
        type: "number",
    },
    {
        name: "left",
        baseName: "left",
        type: "number",
    },
    {
        name: "right",
        baseName: "right",
        type: "number",
    }
];
exports.Coordinates = Coordinates;
/**
 * Template methods options.
 */
class CreateTemplateOptions {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return CreateTemplateOptions.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
CreateTemplateOptions.attributeTypeMap = [
    {
        name: "template",
        baseName: "template",
        type: "Template",
    },
    {
        name: "templatePath",
        baseName: "templatePath",
        type: "string",
    },
    {
        name: "storageName",
        baseName: "storageName",
        type: "string",
    }
];
exports.CreateTemplateOptions = CreateTemplateOptions;
/**
 * Provides parameters for the table detection algorithms.
 */
class DetectorParameters {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return DetectorParameters.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
DetectorParameters.attributeTypeMap = [
    {
        name: "minRowCount",
        baseName: "minRowCount",
        type: "number",
    },
    {
        name: "minColumnCount",
        baseName: "minColumnCount",
        type: "number",
    },
    {
        name: "minVerticalSpace",
        baseName: "minVerticalSpace",
        type: "number",
    },
    {
        name: "hasMergedCells",
        baseName: "hasMergedCells",
        type: "boolean",
    },
    {
        name: "rectangle",
        baseName: "rectangle",
        type: "Rectangle",
    },
    {
        name: "verticalSeparators",
        baseName: "verticalSeparators",
        type: "Array<number>",
    }
];
exports.DetectorParameters = DetectorParameters;
/**
 * Class for disc space information.
 */
class DiscUsage {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return DiscUsage.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
DiscUsage.attributeTypeMap = [
    {
        name: "usedSize",
        baseName: "usedSize",
        type: "number",
    },
    {
        name: "totalSize",
        baseName: "totalSize",
        type: "number",
    }
];
exports.DiscUsage = DiscUsage;
/**
 * The error details
 */
class ErrorDetails {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ErrorDetails.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ErrorDetails.attributeTypeMap = [
    {
        name: "requestId",
        baseName: "requestId",
        type: "string",
    },
    {
        name: "date",
        baseName: "date",
        type: "Date",
    }
];
exports.ErrorDetails = ErrorDetails;
/**
 * Field of document template
 */
class Field {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Field.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Field.attributeTypeMap = [
    {
        name: "fieldName",
        baseName: "fieldName",
        type: "string",
    },
    {
        name: "pageIndex",
        baseName: "pageIndex",
        type: "number",
    },
    {
        name: "fieldPosition",
        baseName: "fieldPosition",
        type: "FieldPosition",
    }
];
exports.Field = Field;
/**
 * Class for document field data.
 */
class FieldData {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FieldData.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FieldData.attributeTypeMap = [
    {
        name: "name",
        baseName: "name",
        type: "string",
    },
    {
        name: "pageIndex",
        baseName: "pageIndex",
        type: "number",
    },
    {
        name: "pageArea",
        baseName: "pageArea",
        type: "PageArea",
    },
    {
        name: "linkedField",
        baseName: "linkedField",
        type: "FieldData",
    }
];
exports.FieldData = FieldData;
/**
 * Field position class.
 */
class FieldPosition {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FieldPosition.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FieldPosition.attributeTypeMap = [
    {
        name: "fieldPositionType",
        baseName: "fieldPositionType",
        type: "string",
    },
    {
        name: "rectangle",
        baseName: "rectangle",
        type: "Rectangle",
    },
    {
        name: "regex",
        baseName: "regex",
        type: "string",
    },
    {
        name: "matchCase",
        baseName: "matchCase",
        type: "boolean",
    },
    {
        name: "linkedFieldName",
        baseName: "linkedFieldName",
        type: "string",
    },
    {
        name: "isLeftLinked",
        baseName: "isLeftLinked",
        type: "boolean",
    },
    {
        name: "isRightLinked",
        baseName: "isRightLinked",
        type: "boolean",
    },
    {
        name: "isTopLinked",
        baseName: "isTopLinked",
        type: "boolean",
    },
    {
        name: "isBottomLinked",
        baseName: "isBottomLinked",
        type: "boolean",
    },
    {
        name: "searchArea",
        baseName: "searchArea",
        type: "Size",
    },
    {
        name: "autoScale",
        baseName: "autoScale",
        type: "boolean",
    }
];
exports.FieldPosition = FieldPosition;
/**
 * File info
 */
class FileInfo {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FileInfo.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FileInfo.attributeTypeMap = [
    {
        name: "filePath",
        baseName: "filePath",
        type: "string",
    },
    {
        name: "storageName",
        baseName: "storageName",
        type: "string",
    },
    {
        name: "password",
        baseName: "password",
        type: "string",
    }
];
exports.FileInfo = FileInfo;
/**
 * Represents the file type.
 */
class FileType {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FileType.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FileType.attributeTypeMap = [
    {
        name: "fileFormat",
        baseName: "fileFormat",
        type: "string",
    },
    {
        name: "extension",
        baseName: "extension",
        type: "string",
    }
];
exports.FileType = FileType;
/**
 * File versions FileVersion.
 */
class FileVersions {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FileVersions.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FileVersions.attributeTypeMap = [
    {
        name: "value",
        baseName: "value",
        type: "Array<FileVersion>",
    }
];
exports.FileVersions = FileVersions;
/**
 * Files list
 */
class FilesList {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FilesList.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FilesList.attributeTypeMap = [
    {
        name: "value",
        baseName: "value",
        type: "Array<StorageFile>",
    }
];
exports.FilesList = FilesList;
/**
 * File upload result
 */
class FilesUploadResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FilesUploadResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FilesUploadResult.attributeTypeMap = [
    {
        name: "uploaded",
        baseName: "uploaded",
        type: "Array<string>",
    },
    {
        name: "errors",
        baseName: "errors",
        type: "Array<Error>",
    }
];
exports.FilesUploadResult = FilesUploadResult;
/**
 * File-format
 */
class Format {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Format.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Format.attributeTypeMap = [
    {
        name: "extension",
        baseName: "extension",
        type: "string",
    },
    {
        name: "fileFormat",
        baseName: "fileFormat",
        type: "string",
    }
];
exports.Format = Format;
/**
 * Describes object which contains list of supported file formats.
 */
class FormatsResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FormatsResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FormatsResult.attributeTypeMap = [
    {
        name: "formats",
        baseName: "formats",
        type: "Array<Format>",
    }
];
exports.FormatsResult = FormatsResult;
/**
 * Provides the options which are used for formatted text extraction.
 */
class FormattedTextOptions {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FormattedTextOptions.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FormattedTextOptions.attributeTypeMap = [
    {
        name: "mode",
        baseName: "mode",
        type: "string",
    }
];
exports.FormattedTextOptions = FormattedTextOptions;
/**
 * Represents an image.
 */
class Image {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Image.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Image.attributeTypeMap = [
    {
        name: "path",
        baseName: "path",
        type: "string",
    },
    {
        name: "downloadUrl",
        baseName: "downloadUrl",
        type: "string",
    },
    {
        name: "pageIndex",
        baseName: "pageIndex",
        type: "number",
    },
    {
        name: "rotation",
        baseName: "rotation",
        type: "number",
    },
    {
        name: "fileFormat",
        baseName: "fileFormat",
        type: "string",
    },
    {
        name: "rectangle",
        baseName: "rectangle",
        type: "Rectangle",
    }
];
exports.Image = Image;
/**
 * Represents page object with image collection.
 */
class ImagePage {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ImagePage.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ImagePage.attributeTypeMap = [
    {
        name: "pageIndex",
        baseName: "pageIndex",
        type: "number",
    },
    {
        name: "images",
        baseName: "images",
        type: "Array<Image>",
    }
];
exports.ImagePage = ImagePage;
/**
 * Images result.
 */
class ImagesResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ImagesResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ImagesResult.attributeTypeMap = [
    {
        name: "images",
        baseName: "images",
        type: "Array<Image>",
    },
    {
        name: "pages",
        baseName: "pages",
        type: "Array<ImagePage>",
    }
];
exports.ImagesResult = ImagesResult;
/**
 * Info result.
 */
class InfoResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return InfoResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
InfoResult.attributeTypeMap = [
    {
        name: "fileType",
        baseName: "fileType",
        type: "FileType",
    },
    {
        name: "size",
        baseName: "size",
        type: "number",
    },
    {
        name: "pageCount",
        baseName: "pageCount",
        type: "number",
    },
    {
        name: "encoding",
        baseName: "encoding",
        type: "string",
    }
];
exports.InfoResult = InfoResult;
/**
 * Error
 */
class ModelError {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ModelError.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ModelError.attributeTypeMap = [
    {
        name: "code",
        baseName: "code",
        type: "string",
    },
    {
        name: "message",
        baseName: "message",
        type: "string",
    },
    {
        name: "description",
        baseName: "description",
        type: "string",
    },
    {
        name: "innerError",
        baseName: "innerError",
        type: "ErrorDetails",
    }
];
exports.ModelError = ModelError;
/**
 * Object exists
 */
class ObjectExist {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ObjectExist.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ObjectExist.attributeTypeMap = [
    {
        name: "exists",
        baseName: "exists",
        type: "boolean",
    },
    {
        name: "isFolder",
        baseName: "isFolder",
        type: "boolean",
    }
];
exports.ObjectExist = ObjectExist;
/**
 * The document page information such as page index and page size.
 */
class Page {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Page.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Page.attributeTypeMap = [
    {
        name: "index",
        baseName: "index",
        type: "number",
    },
    {
        name: "size",
        baseName: "size",
        type: "Size",
    }
];
exports.Page = Page;
/**
 * Class for document page area.
 */
class PageArea {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return PageArea.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
PageArea.attributeTypeMap = [
    {
        name: "rectangle",
        baseName: "rectangle",
        type: "Rectangle",
    },
    {
        name: "page",
        baseName: "page",
        type: "Page",
    },
    {
        name: "pageTextArea",
        baseName: "pageTextArea",
        type: "PageTextArea",
    },
    {
        name: "pageTableArea",
        baseName: "pageTableArea",
        type: "PageTableArea",
    }
];
exports.PageArea = PageArea;
/**
 * Represents a table page area which is used to represent a table in the parsing by template functionality.
 */
class PageTableArea {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return PageTableArea.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
PageTableArea.attributeTypeMap = [
    {
        name: "rowCount",
        baseName: "rowCount",
        type: "number",
    },
    {
        name: "columnCount",
        baseName: "columnCount",
        type: "number",
    },
    {
        name: "pageTableAreaCells",
        baseName: "pageTableAreaCells",
        type: "Array<PageTableAreaCell>",
    }
];
exports.PageTableArea = PageTableArea;
/**
 * Represents a table cell.
 */
class PageTableAreaCell {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return PageTableAreaCell.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
PageTableAreaCell.attributeTypeMap = [
    {
        name: "columnIndex",
        baseName: "columnIndex",
        type: "number",
    },
    {
        name: "columnSpan",
        baseName: "columnSpan",
        type: "number",
    },
    {
        name: "pageArea",
        baseName: "pageArea",
        type: "PageArea",
    },
    {
        name: "rowIndex",
        baseName: "rowIndex",
        type: "number",
    },
    {
        name: "rowSpan",
        baseName: "rowSpan",
        type: "number",
    }
];
exports.PageTableAreaCell = PageTableAreaCell;
/**
 * Represents a page text area which is used to represent a text value in the parsing by template functionality.
 */
class PageTextArea {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return PageTextArea.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
PageTextArea.attributeTypeMap = [
    {
        name: "text",
        baseName: "text",
        type: "string",
    },
    {
        name: "baseLine",
        baseName: "baseLine",
        type: "number",
    },
    {
        name: "areas",
        baseName: "areas",
        type: "Array<PageTextArea>",
    },
    {
        name: "textStyle",
        baseName: "textStyle",
        type: "TextStyle",
    }
];
exports.PageTextArea = PageTextArea;
/**
 * Parse result.
 */
class ParseResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ParseResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ParseResult.attributeTypeMap = [
    {
        name: "count",
        baseName: "count",
        type: "number",
    },
    {
        name: "fieldsData",
        baseName: "fieldsData",
        type: "Array<FieldData>",
    }
];
exports.ParseResult = ParseResult;
/**
 * Base options class.
 */
class ParserOptions {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ParserOptions.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ParserOptions.attributeTypeMap = [
    {
        name: "fileInfo",
        baseName: "fileInfo",
        type: "FileInfo",
    },
    {
        name: "containerItemInfo",
        baseName: "containerItemInfo",
        type: "ContainerItemInfo",
    }
];
exports.ParserOptions = ParserOptions;
/**
 * Class for rectangle position model.
 */
class Point {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Point.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Point.attributeTypeMap = [
    {
        name: "x",
        baseName: "x",
        type: "number",
    },
    {
        name: "y",
        baseName: "y",
        type: "number",
    }
];
exports.Point = Point;
/**
 * Rectangular area on the page.
 */
class Rectangle {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Rectangle.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Rectangle.attributeTypeMap = [
    {
        name: "position",
        baseName: "position",
        type: "Point",
    },
    {
        name: "size",
        baseName: "size",
        type: "Size",
    },
    {
        name: "coordinates",
        baseName: "coordinates",
        type: "Coordinates",
    }
];
exports.Rectangle = Rectangle;
/**
 * Represents a size of rectangular area.
 */
class Size {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Size.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Size.attributeTypeMap = [
    {
        name: "height",
        baseName: "height",
        type: "number",
    },
    {
        name: "width",
        baseName: "width",
        type: "number",
    }
];
exports.Size = Size;
/**
 * Storage exists
 */
class StorageExist {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return StorageExist.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
StorageExist.attributeTypeMap = [
    {
        name: "exists",
        baseName: "exists",
        type: "boolean",
    }
];
exports.StorageExist = StorageExist;
/**
 * File or folder information
 */
class StorageFile {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return StorageFile.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
StorageFile.attributeTypeMap = [
    {
        name: "name",
        baseName: "name",
        type: "string",
    },
    {
        name: "isFolder",
        baseName: "isFolder",
        type: "boolean",
    },
    {
        name: "modifiedDate",
        baseName: "modifiedDate",
        type: "Date",
    },
    {
        name: "size",
        baseName: "size",
        type: "number",
    },
    {
        name: "path",
        baseName: "path",
        type: "string",
    }
];
exports.StorageFile = StorageFile;
/**
 * Document template table
 */
class Table {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Table.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Table.attributeTypeMap = [
    {
        name: "tableName",
        baseName: "tableName",
        type: "string",
    },
    {
        name: "pageIndex",
        baseName: "pageIndex",
        type: "number",
    },
    {
        name: "detectorParameters",
        baseName: "detectorParameters",
        type: "DetectorParameters",
    },
    {
        name: "tableLayout",
        baseName: "tableLayout",
        type: "TableLayout",
    }
];
exports.Table = Table;
/**
 * Provides the template table layout which is used by Table to define table position.
 */
class TableLayout {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return TableLayout.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
TableLayout.attributeTypeMap = [
    {
        name: "verticalSeparators",
        baseName: "verticalSeparators",
        type: "Array<number>",
    },
    {
        name: "horizontalSeparators",
        baseName: "horizontalSeparators",
        type: "Array<number>",
    }
];
exports.TableLayout = TableLayout;
/**
 * User-generated template to extract metadata from the document.
 */
class Template {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Template.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Template.attributeTypeMap = [
    {
        name: "fields",
        baseName: "fields",
        type: "Array<Field>",
    },
    {
        name: "tables",
        baseName: "tables",
        type: "Array<Table>",
    }
];
exports.Template = Template;
/**
 * Template methods options.
 */
class TemplateOptions {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return TemplateOptions.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
TemplateOptions.attributeTypeMap = [
    {
        name: "templatePath",
        baseName: "templatePath",
        type: "string",
    },
    {
        name: "storageName",
        baseName: "storageName",
        type: "string",
    }
];
exports.TemplateOptions = TemplateOptions;
/**
 * Document template result.
 */
class TemplateResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return TemplateResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
TemplateResult.attributeTypeMap = [
    {
        name: "url",
        baseName: "url",
        type: "string",
    },
    {
        name: "templatePath",
        baseName: "templatePath",
        type: "string",
    }
];
exports.TemplateResult = TemplateResult;
/**
 * Extracted text page class.
 */
class TextPage {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return TextPage.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
TextPage.attributeTypeMap = [
    {
        name: "pageIndex",
        baseName: "pageIndex",
        type: "number",
    },
    {
        name: "text",
        baseName: "text",
        type: "string",
    }
];
exports.TextPage = TextPage;
/**
 * The result od text extraction.
 */
class TextResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return TextResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
TextResult.attributeTypeMap = [
    {
        name: "pages",
        baseName: "pages",
        type: "Array<TextPage>",
    },
    {
        name: "text",
        baseName: "text",
        type: "string",
    }
];
exports.TextResult = TextResult;
/**
 * The text style such as font size, font name an so on.
 */
class TextStyle {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return TextStyle.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
TextStyle.attributeTypeMap = [
    {
        name: "fontName",
        baseName: "fontName",
        type: "string",
    },
    {
        name: "fontSize",
        baseName: "fontSize",
        type: "number",
    },
    {
        name: "isBold",
        baseName: "isBold",
        type: "boolean",
    },
    {
        name: "isItalic",
        baseName: "isItalic",
        type: "boolean",
    },
    {
        name: "name",
        baseName: "name",
        type: "string",
    }
];
exports.TextStyle = TextStyle;
/**
 * Barcode options.
 */
class BarcodesOptions extends ParserOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BarcodesOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
BarcodesOptions.attributeTypeMap = [
    {
        name: "outputPath",
        baseName: "outputPath",
        type: "string",
    },
    {
        name: "startPageNumber",
        baseName: "startPageNumber",
        type: "number",
    },
    {
        name: "countPagesToExtract",
        baseName: "countPagesToExtract",
        type: "number",
    }
];
exports.BarcodesOptions = BarcodesOptions;
/**
 * Container options.
 */
class ContainerOptions extends ParserOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ContainerOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
ContainerOptions.attributeTypeMap = [];
exports.ContainerOptions = ContainerOptions;
/**
 * File Version
 */
class FileVersion extends StorageFile {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FileVersion.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
FileVersion.attributeTypeMap = [
    {
        name: "versionId",
        baseName: "versionId",
        type: "string",
    },
    {
        name: "isLatest",
        baseName: "isLatest",
        type: "boolean",
    }
];
exports.FileVersion = FileVersion;
/**
 * Image options.
 */
class ImagesOptions extends ParserOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImagesOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
ImagesOptions.attributeTypeMap = [
    {
        name: "outputPath",
        baseName: "outputPath",
        type: "string",
    },
    {
        name: "startPageNumber",
        baseName: "startPageNumber",
        type: "number",
    },
    {
        name: "countPagesToExtract",
        baseName: "countPagesToExtract",
        type: "number",
    }
];
exports.ImagesOptions = ImagesOptions;
/**
 * Info options
 */
class InfoOptions extends ParserOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(InfoOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
InfoOptions.attributeTypeMap = [];
exports.InfoOptions = InfoOptions;
/**
 * Parse options.
 */
class ParseOptions extends ParserOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ParseOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
ParseOptions.attributeTypeMap = [
    {
        name: "template",
        baseName: "template",
        type: "Template",
    },
    {
        name: "templatePath",
        baseName: "templatePath",
        type: "string",
    }
];
exports.ParseOptions = ParseOptions;
/**
 * Extract options.
 */
class TextOptions extends ParserOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
TextOptions.attributeTypeMap = [
    {
        name: "formattedTextOptions",
        baseName: "formattedTextOptions",
        type: "FormattedTextOptions",
    },
    {
        name: "startPageNumber",
        baseName: "startPageNumber",
        type: "number",
    },
    {
        name: "countPagesToExtract",
        baseName: "countPagesToExtract",
        type: "number",
    }
];
exports.TextOptions = TextOptions;
const enumsMap = {};
exports.enumsMap = enumsMap;
const typeMap = {
    Barcode,
    BarcodePage,
    BarcodesResult,
    ContainerItem,
    ContainerItemInfo,
    ContainerResult,
    Coordinates,
    CreateTemplateOptions,
    DetectorParameters,
    DiscUsage,
    ErrorDetails,
    Field,
    FieldData,
    FieldPosition,
    FileInfo,
    FileType,
    FileVersions,
    FilesList,
    FilesUploadResult,
    Format,
    FormatsResult,
    FormattedTextOptions,
    Image,
    ImagePage,
    ImagesResult,
    InfoResult,
    ModelError,
    ObjectExist,
    Page,
    PageArea,
    PageTableArea,
    PageTableAreaCell,
    PageTextArea,
    ParseResult,
    ParserOptions,
    Point,
    Rectangle,
    Size,
    StorageExist,
    StorageFile,
    Table,
    TableLayout,
    Template,
    TemplateOptions,
    TemplateResult,
    TextPage,
    TextResult,
    TextStyle,
    BarcodesOptions,
    ContainerOptions,
    FileVersion,
    ImagesOptions,
    InfoOptions,
    ParseOptions,
    TextOptions,
};
exports.typeMap = typeMap;
/**
 * Request model for CopyFile operation.
 */
class CopyFileRequest {
    constructor(srcPath, destPath, srcStorageName, destStorageName, versionId) {
        this.srcPath = srcPath;
        this.destPath = destPath;
        this.srcStorageName = srcStorageName;
        this.destStorageName = destStorageName;
        this.versionId = versionId;
    }
}
exports.CopyFileRequest = CopyFileRequest;
/**
 * Request model for DeleteFile operation.
 */
class DeleteFileRequest {
    constructor(path, storageName, versionId) {
        this.path = path;
        this.storageName = storageName;
        this.versionId = versionId;
    }
}
exports.DeleteFileRequest = DeleteFileRequest;
/**
 * Request model for DownloadFile operation.
 */
class DownloadFileRequest {
    constructor(path, storageName, versionId) {
        this.path = path;
        this.storageName = storageName;
        this.versionId = versionId;
    }
}
exports.DownloadFileRequest = DownloadFileRequest;
/**
 * Request model for MoveFile operation.
 */
class MoveFileRequest {
    constructor(srcPath, destPath, srcStorageName, destStorageName, versionId) {
        this.srcPath = srcPath;
        this.destPath = destPath;
        this.srcStorageName = srcStorageName;
        this.destStorageName = destStorageName;
        this.versionId = versionId;
    }
}
exports.MoveFileRequest = MoveFileRequest;
/**
 * Request model for UploadFile operation.
 */
class UploadFileRequest {
    constructor(path, file, storageName) {
        this.path = path;
        this.file = file;
        this.storageName = storageName;
    }
}
exports.UploadFileRequest = UploadFileRequest;
/**
 * Request model for CopyFolder operation.
 */
class CopyFolderRequest {
    constructor(srcPath, destPath, srcStorageName, destStorageName) {
        this.srcPath = srcPath;
        this.destPath = destPath;
        this.srcStorageName = srcStorageName;
        this.destStorageName = destStorageName;
    }
}
exports.CopyFolderRequest = CopyFolderRequest;
/**
 * Request model for CreateFolder operation.
 */
class CreateFolderRequest {
    constructor(path, storageName) {
        this.path = path;
        this.storageName = storageName;
    }
}
exports.CreateFolderRequest = CreateFolderRequest;
/**
 * Request model for DeleteFolder operation.
 */
class DeleteFolderRequest {
    constructor(path, storageName, recursive) {
        this.path = path;
        this.storageName = storageName;
        this.recursive = recursive;
    }
}
exports.DeleteFolderRequest = DeleteFolderRequest;
/**
 * Request model for GetFilesList operation.
 */
class GetFilesListRequest {
    constructor(path, storageName) {
        this.path = path;
        this.storageName = storageName;
    }
}
exports.GetFilesListRequest = GetFilesListRequest;
/**
 * Request model for MoveFolder operation.
 */
class MoveFolderRequest {
    constructor(srcPath, destPath, srcStorageName, destStorageName) {
        this.srcPath = srcPath;
        this.destPath = destPath;
        this.srcStorageName = srcStorageName;
        this.destStorageName = destStorageName;
    }
}
exports.MoveFolderRequest = MoveFolderRequest;
/**
 * Request model for Container operation.
 */
class ContainerRequest {
    constructor(options) {
        this.options = options;
    }
}
exports.ContainerRequest = ContainerRequest;
/**
 * Request model for GetInfo operation.
 */
class GetInfoRequest {
    constructor(options) {
        this.options = options;
    }
}
exports.GetInfoRequest = GetInfoRequest;
/**
 * Request model for Barcodes operation.
 */
class BarcodesRequest {
    constructor(options) {
        this.options = options;
    }
}
exports.BarcodesRequest = BarcodesRequest;
/**
 * Request model for Images operation.
 */
class ImagesRequest {
    constructor(options) {
        this.options = options;
    }
}
exports.ImagesRequest = ImagesRequest;
/**
 * Request model for Parse operation.
 */
class ParseRequest {
    constructor(options) {
        this.options = options;
    }
}
exports.ParseRequest = ParseRequest;
/**
 * Request model for Text operation.
 */
class TextRequest {
    constructor(options) {
        this.options = options;
    }
}
exports.TextRequest = TextRequest;
/**
 * Request model for GetDiscUsage operation.
 */
class GetDiscUsageRequest {
    constructor(storageName) {
        this.storageName = storageName;
    }
}
exports.GetDiscUsageRequest = GetDiscUsageRequest;
/**
 * Request model for GetFileVersions operation.
 */
class GetFileVersionsRequest {
    constructor(path, storageName) {
        this.path = path;
        this.storageName = storageName;
    }
}
exports.GetFileVersionsRequest = GetFileVersionsRequest;
/**
 * Request model for ObjectExists operation.
 */
class ObjectExistsRequest {
    constructor(path, storageName, versionId) {
        this.path = path;
        this.storageName = storageName;
        this.versionId = versionId;
    }
}
exports.ObjectExistsRequest = ObjectExistsRequest;
/**
 * Request model for StorageExists operation.
 */
class StorageExistsRequest {
    constructor(storageName) {
        this.storageName = storageName;
    }
}
exports.StorageExistsRequest = StorageExistsRequest;
/**
 * Request model for CreateTemplate operation.
 */
class CreateTemplateRequest {
    constructor(options) {
        this.options = options;
    }
}
exports.CreateTemplateRequest = CreateTemplateRequest;
/**
 * Request model for DeleteTemplate operation.
 */
class DeleteTemplateRequest {
    constructor(options) {
        this.options = options;
    }
}
exports.DeleteTemplateRequest = DeleteTemplateRequest;
/**
 * Request model for GetTemplate operation.
 */
class GetTemplateRequest {
    constructor(options) {
        this.options = options;
    }
}
exports.GetTemplateRequest = GetTemplateRequest;
